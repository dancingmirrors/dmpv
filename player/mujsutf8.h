/******************************************************************************
 * mujsutf8.h: mostly-transparent UTF-8 wrapper for mujs APIs
 * Copyright 2019 Avi Halachmi (:avih) avihpit@yahoo.com
 * [ISC]
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 ******************************************************************************
 *
 *
 * This file wraps all mujs (CESU-8) string APIs with UTF-8 functions.
 *
 * How to use:
 *
 * Just include this file after including mujs.h. See also: Bugs, Notes.
 *
 *
 * How it works:
 *
 * For mujs APIs which take/return strings, e.g. js_torepr, this file defines
 * the variants c_js_torepr and u_js_torepr. The c_ variant is a direct wrapper
 * of js_torepr, and the u_ variant has the same prototype but exposes a UTF-8
 * API which converts inputs from UTF-8 to CESU-8 (if required), and converts
 * return values from CESU-8 to UTF-8 (if required).
 *
 * It then defines js_torepr as u_js_torepr such that the normal names become
 * UTF-8 APIs, while the CESU-8 APIs are still accessible via the c_ variants.
 *
 *
 * Bugs:
 *
 * - js_loadfile and js_ploadfile currently (mujs 1.0.6) assume the source file
 *   on disk is CESU-8. This is a mujs bug and U8J does not try to fix it.
 *   It's recommended to read the file into memory and use u_js_[p]loadstring.
 *
 *
 * Notes:
 *
 * - U8J is stateless and does not store values for later use. Specifically:
 *
 *   - If alloc/actx are provided at js_newstate - mujs uses them as expected,
 *     but U8J still defaults to realloc/free for internal needs (stateless and
 *     can't/doesn't store actx). To use a custom alloc also for U8J needs:
 *     implement u8j_alloc(J, ptr, size). See comment of U8J_ALLOC_USER.
 *
 *   - Callbacks are not wrapped automatically. If you need UTF-8 inputs at
 *     callbacks like js_HasProperty or js_Report you should wrap your callback
 *     with one provided by U8J, e.g.:
 *
 *          void my_utf8_report_fn(js_State *J, const char *utf8_message) {
 *              fprintf(stderr, "%s\n", utf8_message);
 *          }
 *          void my_report_wrapper(js_State *J, const char *cesu8_message) {
 *              u8j_wrap_report(my_utf8_report_fn, J, cesu8_message);
 *          }
 *          // ...
 *          js_setreport(J, my_report_wrapper);
 *
 *     The prototypes and return values of u8j_wrap_* is identical to the
 *     wrapped function with an additional function pointer as first argument.
 *
 *     callback: js_Report        js_Put        js_Delete        js_HasProperty
 *     Wrapper:  u8j_wrap_report  u8j_wrap_put  u8j_wrap_delete  u8j_wrap_has
 *
 * - Unless noted otherwise, U8J reserves the prefixes c_ and u_ with mujs API
 *   names, the prefix `U8J_' with C preprocessor definitions, as well as the
 *   prefix `u8j_' with C identifiers, JS userdata tags, and property names of
 *   a JS iterator object (not the iterated names, for instance, do NOT do:
 *   js_pushiterator(J,..); js_push*(J,..); js_setproperty(J, -2, "u8j_x"); ).
 *
 *
 * Strings which are not converted:
 *
 * - reference names and typeof values don't need conversion. Both would be
 *   considered opaque anyway because they're generated by mujs.
 *
 * - registry names and filename arguments (like at u_js_loadstring) are not
 *   accessible as JS strings and are not converted. filename might end up as
 *   part of an error string, but then it's likely to be used as UTF-8 anyway,
 *   e.g. with u_js_getproperty(J, "stackTrace") or if reported to js_Report.
 *
 * - userdata tags and `error' sentinels (like at js_trystring(J, idx, error))
 *   are considered opaque and not converted. Note that userdata tags might end
 *   up as part of a JS string ("[object <tag>]"), so it's recommended to use
 *   tags which don't need conversion, or manage the conversion yourself.
 */

#define U8J_VERSION_MAJOR 1
#define U8J_VERSION_MINOR 0


/*
 * Configuration: The following may be defined before including this file:
 *
 * - U8J_DO_INCLUDES as 0 to skip the builtin includes (default 1).
 * - U8J_IMPL_ALLOC as U8J_ALLOC_USER - see below (default U8J_ALLOC_AUTO).
 * - U8J_IMPL_STACK_BUF_SIZ as as a size in bytes (default 256).
 * - U8J_AUTO_MAP as 0 to skip the automatic mapping of mujs APIs to the u_
 *                names (i.e. the normal and c_ names are direct mujs calls,
 *                and the u_ (and u8j_) names provide UTF-8 functionality).
 */

#ifndef U8J_DO_INCLUDES
    #define U8J_DO_INCLUDES 1
#endif
#if U8J_DO_INCLUDES
    #include <stdlib.h>  /* size_t, realloc */
    #include <stdio.h>   /* vsnprintf at js_[name]error(J, fmt, ...) */
    #include <stdarg.h>  /* js_[name]error(J, fmt, ...) */
#endif

#ifndef U8J_AUTO_MAP
    #define U8J_AUTO_MAP 1
#endif

/* (stack) buffer size - avoid some memory allocation if the string fits this */
#ifndef U8J_IMPL_STACK_BUF_SIZ
    #define U8J_IMPL_STACK_BUF_SIZ 256
#endif


/* currently uses realloc, ignoring alloc/actx at js_newstate */
#define U8J_ALLOC_AUTO 0

/*
 * The user should implement `u8j_alloc' for this declaration:
 *     U8J_API void * u8j_alloc(js_State *J, void *ptr, U8J_SIZ size);
 *
 * This function should use ptr/size exactly like the alloc function at
 * js_newstate does, and it will be used only for internal U8J conversions.
 *
 * You'd probably want to store The actual alloc/actx values at the context,
 * set it with js_setcontext right after js_newstate, make sure it stays until
 * js_freestate returns, while u8j_alloc grabs and uses them via js_getcontext.
 */
#define U8J_ALLOC_USER 1

#ifndef U8J_IMPL_ALLOC
    #define U8J_IMPL_ALLOC U8J_ALLOC_AUTO
#endif


#ifdef __GNUC__
    #define U8J__UNUSED __attribute__ ((unused))
#else
    #define U8J_UNUSED
#endif

/* mujs (and our) APIs use only int, but as U8J_SIZ where it should be size_t */
typedef int U8J_SIZ;
#define U8J_API U8J__UNUSED static


/* declare u8j_alloc if the user implements it later */
U8J_API void *u8j_alloc(js_State *J, void *ptr, U8J_SIZ siz);

#if U8J_IMPL_ALLOC == U8J_ALLOC_AUTO
    /* we provide the definition if the user doesn't */
    U8J_API void *u8j_alloc(js_State *J /* ignored */, void *ptr, U8J_SIZ siz) {
        if (siz)
            return realloc(ptr, (size_t)siz);
        if (ptr)
            free(ptr);
        return 0;
    }
#endif


/* define mujs.h macros if needed in case mujs.h changes in the future */

#ifndef JS_NORETURN
    /* copied verbatim from mujs.h version 1.0.6 */

    /* noreturn is a GCC extension */
    #ifdef __GNUC__
    #define JS_NORETURN __attribute__((noreturn))
    #else
    #ifdef _MSC_VER
    #define JS_NORETURN __declspec(noreturn)
    #else
    #define JS_NORETURN
    #endif
    #endif
#endif

#ifndef JS_PRINTFLIKE
    /* copied verbatim from mujs.h version 1.0.6 */

    /* GCC can do type checking of printf strings */
    #ifdef __printflike
    #define JS_PRINTFLIKE __printflike
    #else
    #if __GNUC__ > 2 || __GNUC__ == 2 && __GNUC_MINOR__ >= 7
    #define JS_PRINTFLIKE(fmtarg, firstvararg) \
        __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
    #else
    #define JS_PRINTFLIKE(fmtarg, firstvararg)
    #endif
    #endif
#endif


/******************************************************
 * Generic CESU-8 and UTF-8 test/conversion utilities *
 ******************************************************/

/*
 * Unicode supplementary codepoint is U+10000 or higher. In UTF-8 it's a 4-bytes
 * sequence and in CESU-8 it's 6 (pair of 3-bytes surrogates). Other codepoints
 * are encoded as identical sequences in UTF-8 and CESU-8.
 *
 * CP >= U+10000 in UTF-8: 11110ccc 10ccbbbb 10bbbbaa 10aaaaaa
 * The top 5 bits (ccccc) must be non-zero and equal-to-or-less-than 0x10
 *
 * CP >= U+10000 in CESU-8: 11101101 1010yyyy 10bbbbbb 11101101 1011bbaa 10aaaaaa
 * the CP lower 16 bits are bb...aa, the top 5 are yyyy + 1
 */

/* tests up to 6 bytes, aborts crrectly on string termination */
static inline int u8j__is_cesu8_smp(const unsigned char *s)
{
    return s[0] == 0xed && (s[1] & 0xf0) == 0xa0 && (s[2] & 0xc0) == 0x80 &&
           s[3] == 0xed && (s[4] & 0xf0) == 0xb0 && (s[5] & 0xc0) == 0x80;
}

/* writes utf8_len+1 bytes to utf8_dst (adds '\0').
 * utf8_len must come from u8j_[l]utf8_len(..) and must not be 0.
 * conversion can be in-place if src and dst are the same (utf8 is shorter). */
U8J_API void u8j_write_utf8(const char *cesu8_src, char *utf8_dst, U8J_SIZ utf8_len)
{
    const unsigned char *s = (const unsigned char *)cesu8_src;
    unsigned char *dst = (unsigned char *)utf8_dst;
    unsigned char * const fin = dst + utf8_len;
    unsigned char top5;

    while (dst <= fin - 4) {
        if (u8j__is_cesu8_smp(s)) {
            top5 = (s[1] & 0x0f) + 1;

            dst[0] = 0xf0 | top5 >> 2;
            dst[1] = 0x80 | (top5 & 0x03) << 4 | (s[2] & 0x3f) >> 2;
            dst[2] = 0x80 | (s[2] & 0x03) << 4 | (s[4] & 0x0f);
            dst[3] = s[5];

            s += 6;
            dst += 4;

        } else {
            *dst++ = *s++;
        }
    }
    while (dst < fin)
        *dst++ = *s++;

    *dst = 0;
}

/* 0 if no conversion to UTF-8 is required, else the expected UTF-8 strlen */
U8J_API U8J_SIZ u8j_utf8_len(const char *cesu8)
{
    U8J_SIZ i = 0, smp_count = 0;
    if (!cesu8)
        return 0;  /* no conversion required */

    for (; cesu8[i]; i++) {
        if (u8j__is_cesu8_smp((const unsigned char *)cesu8 + i))
            smp_count++;
    }

    return smp_count ? i - smp_count * 2 : 0;
}

U8J_API U8J_SIZ u8j_lutf8_len(const char *cesu8, U8J_SIZ cesu8_len)
{
    U8J_SIZ i = 0, smp_count = 0;
    if (cesu8_len < 6)
        return 0;  /* no conversion required */

    for (; i <= cesu8_len - 6; i++) {
        if (u8j__is_cesu8_smp((const unsigned char *)cesu8 + i))
            smp_count++;
    }

    return smp_count ? i - smp_count * 2 : 0;
}


/* tests up to 4 bytes, aborts crrectly on string termination */
static inline int u8j__is_utf8_smp(const unsigned char *s)
{
    return (s[0] & 0xf8) == 0xf0 &&
           (s[1] & 0xc0) == 0x80 && (s[2] & 0xc0) == 0x80 && (s[3] & 0xc0) == 0x80 &&
           !(s[0] & 0x04) != !((s[0] & 0x03) | (s[1] & 0x30)) /* top5: 0x01..0x10 */;
}

/* writes cesu8_len+1 bytes to cesu8_dst (adds '\0').
 * cesu8_len must come from u8j_[l]cesu8_len(..) and must not be 0.  */
U8J_API void u8j_write_cesu8(const char *utf8_src, char *cesu8_dst, U8J_SIZ cesu8_len)
{
    const unsigned char *s = (const unsigned char *)utf8_src;
    unsigned char *dst = (unsigned char *)cesu8_dst;
    unsigned char * const fin = dst + cesu8_len;
    unsigned char top5;

    while (dst <= fin - 6) {
        if (u8j__is_utf8_smp(s)) {
            top5 = (s[0] & 0x07) << 2 | (s[1] & 0x30) >> 4;

            dst[0] = 0xed;
            dst[1] = 0xa0 | (top5 - 1);
            dst[2] = 0x80 | (s[1] & 0x0f) << 2 | (s[2] & 0x30) >> 4;

            dst[3] = 0xed;
            dst[4] = 0xb0 | (s[2] & 0x0f);
            dst[5] = s[3];

            s += 4;
            dst += 6;

        } else {
            *dst++ = *s++;
        }
    }
    while (dst < fin)
        *dst++ = *s++;

    *dst = 0;
}

/* 0 if no conversion to CESU-8 is required, else the expected CESU-8 strlen */
U8J_API U8J_SIZ u8j_cesu8_len(const char * const utf8)
{
    U8J_SIZ i = 0, smp_count = 0;
    if (!utf8)
        return 0;

    for (; utf8[i]; i++) {
        if (u8j__is_utf8_smp((const unsigned char *)utf8 + i))
            smp_count++;
    }

    /* currently we don't check if the addition wraps-around */
    return smp_count ? i + smp_count * 2 : 0;
}

U8J_API U8J_SIZ u8j_lcesu8_len(const char *utf8, U8J_SIZ utf8_len)
{
    U8J_SIZ i = 0, smp_count = 0;
    /* we allow NULL utf8 if utf8_len implies an actual buffer */
    if (utf8_len < 4)
        return 0;

    for (; i <= utf8_len - 4; i++) {
        if (u8j__is_utf8_smp((const unsigned char *)utf8 + i))
            smp_count++;
    }

    return smp_count ? utf8_len + smp_count * 2 : 0;
}


/**************************
 * u8j__malloc, u8j__free *
 **************************/

static void *u8j__malloc(js_State *J, U8J_SIZ siz) {
    void *ptr = u8j_alloc(J, NULL, siz);
    if (!ptr) {
        js_report(J, "U8J OOM");
        js_pushliteral(J, "U8J OOM");
        js_throw(J);
    }
    return ptr;
}

/* has the same prototype as js_Finalizer, can and is used as such */
static void u8j__free(js_State *J, void *ptr) {
    u8j_alloc(J, ptr, 0);
}


/****************************************
 * Wrappers for basict mujs string APIs *
 ****************************************/

/* base body of input conversion wrapper: assumes cesu8_len, always converts */
#define U8J__IN_CONVERT_CALL(str_var, wrapped_call) \
    if (cesu8_len < U8J_IMPL_STACK_BUF_SIZ) { \
        char buf[U8J_IMPL_STACK_BUF_SIZ]; \
        u8j_write_cesu8(str_var, buf, cesu8_len); \
        str_var = buf; \
        wrapped_call; \
    } else { \
        char * volatile mem = u8j__malloc(J, cesu8_len + 1); \
        u8j_write_cesu8(str_var, mem, cesu8_len); \
        str_var = mem; \
        if (js_try(J)) { \
            u8j__free(J, mem); \
            js_throw(J); \
        } \
        wrapped_call; \
        js_endtry(J); \
        u8j__free(J, mem); \
    }


/* pushstring variants */

/* util: convert utf8 `v' to cesu8 with known result length and push it */
static void u8j__pushslcesu8string(js_State *J, const char *v, U8J_SIZ cesu8_len) {
    U8J__IN_CONVERT_CALL(v, js_pushlstring(J, v, cesu8_len))
}

U8J_API void c_js_pushlstring(js_State *J, const char *v, int n) { js_pushlstring(J, v, n); }
U8J_API void u_js_pushlstring(js_State *J, const char *v, int n) {
    U8J_SIZ cesu8_len = u8j_lcesu8_len(v, n);
    if (cesu8_len == 0)
        js_pushlstring(J, v, n);
    else
        u8j__pushslcesu8string(J, v, cesu8_len);
}

U8J_API void c_js_pushstring(js_State *J, const char *v) { js_pushstring(J, v); }
U8J_API void u_js_pushstring(js_State *J, const char *v) {
    U8J_SIZ cesu8_len = u8j_cesu8_len(v);
    if (cesu8_len == 0)
        js_pushstring(J, v);
    else
        u8j__pushslcesu8string(J, v, cesu8_len);
}

/* literals cannot remain literals if converting, so use string on such case */
U8J_API void c_js_pushliteral(js_State *J, const char *v) { js_pushliteral(J, v); }
U8J_API void u_js_pushliteral(js_State *J, const char *v) {
    U8J_SIZ cesu8_len = u8j_cesu8_len(v);
    if (cesu8_len == 0)
        js_pushliteral(J, v);
    else
        u8j__pushslcesu8string(J, v, cesu8_len);
}


/*
 * UTF-8 return value userdata. This object is not supposed to be used as a JS
 * value - the same way that idx isn't after js_tostring(J, idx), because the
 * call can change the value at idx, and likewise we change it to userdata.
 *
 * Nevertheless, for completeness, we do provide this object with toString and
 * valueOf methods which return a valid CESU-8 string - it has no performance
 * cost. However, accessing these methods is costly-ish (js_newcfunction).
 */

static void u8j__utf8ret_selfValua(js_State *J)
{
    u_js_pushstring(J, (const char *)js_touserdata(J, 0, "u8j_ret"));
}

static int u8j__utf8ret_has(js_State *J, void *p, const char *name)
{
    if (strcmp(name, "toString") && strcmp(name, "valueOf"))
        return 0;
    js_newcfunction(J, u8j__utf8ret_selfValua, "selfValue", 0);
    return 1;
}

/* push (and return) a VM-managed userdata - UTF-8 string from `cesu8' */
static const char *u8j__push_utf8ret(js_State *J, const char *cesu8, U8J_SIZ utf8_len)
{
    char * volatile mem = u8j__malloc(J, utf8_len + 1);
    u8j_write_utf8(cesu8, mem, utf8_len);

    if (js_try(J)) {
        u8j__free(J, mem);
        js_throw(J);
    }
    js_pushnull(J); /* proto. null is good enough, faster than js_getglobal(J, "String") */
    js_newuserdatax(J, "u8j_ret", mem, u8j__utf8ret_has, NULL, NULL, u8j__free);
    js_endtry(J);

    return mem;
}

U8J_API const char *c_js_tostring(js_State *J, int idx) { return js_tostring(J, idx); } \
U8J_API const char *u_js_tostring(js_State *J, int idx) {
    const char *str = js_tostring(J, idx);
    U8J_SIZ utf8_len = u8j_utf8_len(str);
    if (utf8_len == 0)
        return str;

    /* [further] replace idx with the utf8 userdata object */
    str = u8j__push_utf8ret(J, str, utf8_len);
    js_replace(J, idx < 0 ? idx - 1 : idx);
    return str;
}


/*********************************************************************
 * Boilerplate Wrappers for other mujs APIs which take input strings *
 *********************************************************************/

#define U8J__IN_NON(name, proto_args, str_var, call_args) \
    U8J_API void c_js_ ## name proto_args { js_ ## name call_args; } \
    U8J_API void u_js_ ## name proto_args { \
        U8J_SIZ cesu8_len = u8j_cesu8_len(str_var); \
        if (cesu8_len == 0) { \
            js_ ## name call_args; \
        } else { \
            U8J__IN_CONVERT_CALL(str_var, js_ ## name call_args) \
        } \
    }

#define U8J__IN_INT(name, proto_args, str_var, call_args) \
    U8J_API int c_js_ ## name proto_args { return js_ ## name call_args; } \
    U8J_API int u_js_ ## name proto_args { \
        U8J_SIZ cesu8_len = u8j_cesu8_len(str_var); \
        if (cesu8_len == 0) { \
            return js_ ## name call_args; \
        } else { \
            int ret_val; \
            U8J__IN_CONVERT_CALL(str_var, ret_val = js_ ## name call_args) \
            return ret_val; \
        } \
    }

/*
// Example expanded result of
//    U8J__IN_NON(getglobal, (js_State *J, const char *name), name, (J, name))

U8J_API void c_js_getglobal(js_State *J, const char *name) {
    js_getglobal(J, name);
}

U8J_API void u_js_getglobal(js_State *J, const char *name) {
    int cesu8_len = u8j_cesu8_len(name);
    if (cesu8_len == 0) {
        js_getglobal(J, name);
    } else {
        if (cesu8_len < U8J_IMPL_STACK_BUF_SIZ) {
            char buf[U8J_IMPL_STACK_BUF_SIZ];
            u8j_write_cesu8(name, buf, cesu8_len);
            name = buf;
            js_getglobal(J, name);

        } else {
            char * volatile mem = u8j__malloc(J, cesu8_len + 1);
            u8j_write_cesu8(name, mem, cesu8_len);
            name = mem;
            if (js_try(J)) {
                u8j__free(J, mem);
                js_throw(J);
            }
            js_getglobal(J, name);
            js_endtry(J);
            u8j__free(J, mem);
        }
    }
}
*/

/* [p]loadstring: source is converted, filename is not */
U8J__IN_INT(dostring, (js_State *J, const char *source), source, (J, source))
U8J__IN_NON(loadstring, (js_State *J, const char *filename, const char *source), source, (J, filename, source))
U8J__IN_INT(ploadstring, (js_State *J, const char *filename, const char *source), source, (J, filename, source))

U8J__IN_NON(getglobal, (js_State *J, const char *name), name, (J, name))
U8J__IN_NON(setglobal, (js_State *J, const char *name), name, (J, name))
U8J__IN_NON(delglobal, (js_State *J, const char *name), name, (J, name))
U8J__IN_NON(defglobal, (js_State *J, const char *name, int atts), name, (J, name, atts))

U8J__IN_INT(hasproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(getproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(setproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(defproperty, (js_State *J, int idx, const char *name, int atts), name, (J, idx, name, atts))

U8J__IN_NON(delproperty, (js_State *J, int idx, const char *name), name, (J, idx, name))
U8J__IN_NON(defaccessor, (js_State *J, int idx, const char *name, int atts), name, (J, idx, name, atts))

U8J__IN_NON(newcfunction, (js_State *J, js_CFunction fun, const char *name, int length), name, (J, fun, name, length))
U8J__IN_NON(newcconstructor, (js_State *J, js_CFunction fun, js_CFunction con, const char *name, int length), name, (J, fun, con, name, length))
U8J__IN_NON(newregexp, (js_State *J, const char *pattern, int flags), pattern, (J, pattern, flags))

U8J__IN_NON(newstring, (js_State *J, const char *v), v, (J, v))


#undef U8J__IN_NON
#undef U8J__IN_INT


/* js_{c,u}_[new]<name>error */

#define U8J__DERROR(name_err) \
    U8J_API void c_js_new ## name_err(js_State *J, const char *s) { \
        js_new ## name_err(J, s); \
    } \
    U8J_API void u_js_new ## name_err(js_State *J, const char *s) { \
        /* a bit slower than U8J__IN_NON but less code. errors blow anyway */ \
        u_js_pushliteral(J, s); /* push as CESU-8 if conversion is needed */ \
        js_new ## name_err(J, /* c_ */ js_tostring(J, -1)); \
        js_replace(J, -2); \
    } \
    /* we can't have a tiny c_ wrapper with va_list, so reimplement... */ \
    JS_NORETURN JS_PRINTFLIKE(2,3) \
    U8J_API void c_js_ ## name_err(js_State *J, const char *fmt, ...) { \
        va_list ap; \
        char buf[256];  /* same size which mujs itself uses internally */ \
        va_start(ap, fmt); \
        vsnprintf(buf, sizeof buf, fmt, ap); \
        va_end(ap); \
        js_new ## name_err(J, buf); \
        js_throw(J); \
    } \
    JS_NORETURN JS_PRINTFLIKE(2,3) \
    U8J_API void u_js_ ## name_err(js_State *J, const char *fmt, ...) { \
        va_list ap; \
        char buf[256]; \
        va_start(ap, fmt); \
        vsnprintf(buf, sizeof buf, fmt, ap); \
        va_end(ap); \
        u_js_new ## name_err(J, buf); \
        js_throw(J); \
    }

U8J__DERROR(error)
U8J__DERROR(evalerror)
U8J__DERROR(rangeerror)
U8J__DERROR(referenceerror)
U8J__DERROR(syntaxerror)
U8J__DERROR(typeerror)
U8J__DERROR(urierror)

#undef U8J__DERROR


/*****************************************************
 * Wrappers for other mujs APIs which return strings *
 *****************************************************/

/* u_js_torepr - like js_torepr but further converts to utf8 if needed */
U8J_API const char *c_js_torepr(js_State *J, int idx) { return js_torepr(J, idx); } \
U8J_API const char *u_js_torepr(js_State *J, int idx) {
	js_repr(J, idx);
	js_replace(J, idx < 0 ? idx-1 : idx);
	return u_js_tostring(J, idx);
}

/* u_js_try{string,repr} must return the `error' pointer as-is on throw */
#define U8J__OUT_TRY(name) \
    U8J_API const char *c_js_try ## name(js_State *J, int idx, const char *error) { return js_try ## name(J, idx, error); } \
    U8J_API const char *u_js_try ## name(js_State *J, int idx, const char *error) { \
        const char *s; \
        if (js_try(J)) { \
            js_pop(J, 1);  /* the JS error value */ \
            return error; \
        } \
        s = u_js_to ## name(J, idx); \
        js_endtry(J); \
        return s; \
    }

U8J__OUT_TRY(string)
U8J__OUT_TRY(repr)


/* u_js_nextiterator does not have a stack string value which we can replace,
 * so we keep the userdata object as a property "u8j_ret" of the iterator. The
 * pointer remains valid until we set a new one at a later call or until the
 * iterator is garbage-collected.    */
U8J_API const char * c_js_nextiterator(js_State *J, int idx) { return js_nextiterator(J, idx); }
U8J_API const char * u_js_nextiterator(js_State *J, int idx) {
    const char *str = js_nextiterator(J, idx);
    U8J_SIZ utf8_len = u8j_utf8_len(str);
    if (utf8_len == 0)
        return str;

    str = u8j__push_utf8ret(J, str, utf8_len);
    js_setproperty(J, idx < 0 ? idx - 1 : idx, "u8j_ret");
    return str;
}


/*********************
 * Callback wrappers *
 *********************/

#define U8J__PROPERTY_CB_WRAPPER(method, cb_type) \
    U8J_API int u8j_wrap_ ## method(cb_type method, js_State *J, void *p, const char *name) { \
        U8J_SIZ utf8_len = u8j_utf8_len(name); \
        if (utf8_len == 0) { \
            return method(J, p, name); \
        } else { \
            if (utf8_len < U8J_IMPL_STACK_BUF_SIZ) { \
                char buf[U8J_IMPL_STACK_BUF_SIZ]; \
                u8j_write_utf8(name, buf, utf8_len); \
                return method(J, p, buf); \
            } else { \
                int ret_val; \
                char * volatile mem = u8j__malloc(J, utf8_len + 1); \
                u8j_write_utf8(name, mem, utf8_len); \
                if (js_try(J)) { \
                    u8j__free(J, mem); \
                    js_throw(J); \
                } \
                ret_val = method(J, p, mem); \
                js_endtry(J); \
                u8j__free(J, mem); \
                return ret_val; \
            } \
        } \
    }

U8J__PROPERTY_CB_WRAPPER(put, js_Put)
U8J__PROPERTY_CB_WRAPPER(has, js_HasProperty)
U8J__PROPERTY_CB_WRAPPER(delete, js_Delete)


/* js_Report must not throw and should not even do js_try because the report
 * could be for try-stack overflow. We use a fixed stack buffer of 1K (by
 * default), and if a conversion needs more then we report without conversion.
 * As of 1.0.6 mujs reports have max strlen of 511. */
U8J_API void u8j_wrap_report(js_Report report, js_State *J, const char *message) {
    U8J_SIZ utf8_len = u8j_utf8_len(message);
    if (utf8_len == 0 || utf8_len >= U8J_IMPL_STACK_BUF_SIZ /* def=256 */ * 4) {
        report(J, message);
    } else {
        char buf[U8J_IMPL_STACK_BUF_SIZ * 4];
        u8j_write_utf8(message, buf, utf8_len);
        report(J, buf);
    }
}


#if U8J_AUTO_MAP

#define js_dostring u_js_dostring
#define js_loadstring u_js_loadstring
#define js_ploadstring u_js_ploadstring

#define js_getglobal u_js_getglobal
#define js_setglobal u_js_setglobal
#define js_defglobal u_js_defglobal
#define js_delglobal u_js_delglobal

#define js_hasproperty u_js_hasproperty
#define js_getproperty u_js_getproperty
#define js_setproperty u_js_setproperty
#define js_defproperty u_js_defproperty
#define js_delproperty u_js_delproperty
#define js_defaccessor u_js_defaccessor

#define js_newcfunction u_js_newcfunction
#define js_newcconstructor u_js_newcconstructor
#define js_newregexp u_js_newregexp
#define js_newstring u_js_newstring

#define js_pushlstring u_js_pushlstring
#define js_pushstring u_js_pushstring
#define js_pushliteral u_js_pushliteral

#define js_error u_js_error
#define js_evalerror u_js_evalerror
#define js_rangeerror u_js_rangeerror
#define js_referenceerror u_js_referenceerror
#define js_syntaxerror u_js_syntaxerror
#define js_typeerror u_js_typeerror
#define js_urierror u_js_urierror

#define js_newnewerror u_js_newerror
#define js_newevalerror u_js_newevalerror
#define js_newrangeerror u_js_newrangeerror
#define js_newreferenceerror u_js_newreferenceerror
#define js_newsyntaxerror u_js_newsyntaxerror
#define js_newtypeerror u_js_newtypeerror
#define js_newurierror u_js_newurierror

#define js_tostring u_js_tostring
#define js_trystring u_js_trystring
#define js_torepr u_js_torepr
#define js_tryrepr u_js_tryrepr

#define js_nextiterator u_js_nextiterator

#endif /* U8J_AUTO_MAP */
